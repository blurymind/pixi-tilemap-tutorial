<!DOCTYPE html>
<html>
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.0.0/pixi.min.js"></script>
    <!-- <script src="./lib/pixi-tilemap.js"></script> -->
    <script src="./lib/pixi-tilemap.umd.js"></script>
    <script src="./lib/stats.min.js"></script>
  </head>
  <body>
    <script>
    var resolutionX = 800;
    var resolutionY = 600;
    var tileSizeX = 128;
    var tileSizeY = 128;

    var stats = new Stats();
    stats.showPanel(0);
    document.body.appendChild(stats.dom);

    var app = new PIXI.Application(resolutionX, resolutionY);
    document.body.appendChild(app.view);

    console.log(PIXI)
    console.log(PIXI.tilemap)
    var groundTiles;
    var playerTankSprite;
    var playerOffsetX = (resolutionX / 2 - 24);
    var playerOffsetY = (resolutionY / 2 - 24);

    var player = {
        x: 0,
        y: 0
    };

    PIXI.loader
            .add([
                "imgs/imgGround.png",
                "imgs/imgTanks.png",
                "imgs/imgBuildings.png"
            ])
            .load(setup);

    function setup() {

        // Create our tile map based on the ground texture
        groundTiles = new PIXI.tilemap.CompositeRectTileLayer(0, PIXI.utils.TextureCache['imgs/imgGround.png']);
        drawTiles();

        app.stage.addChild(groundTiles);

        // Place a tank in the middle of the texture the tank sprite never moves
        // Instead we move the tile map around the player in out game loop
        var tankTexture = new PIXI.Texture(
                PIXI.utils.TextureCache['imgs/imgTanks.png'],
                new PIXI.Rectangle(0 * 48, 0, 48, 48)
        );

        playerTankSprite = new PIXI.Sprite(tankTexture);
        playerTankSprite.x = playerOffsetX;
        playerTankSprite.y = playerOffsetY;
        app.stage.addChild(playerTankSprite);

        gameLoop();
    }

    function drawTiles() {
        var numberOfTiles = parseInt(resolutionX / tileSizeX) + 10;

        // We need to calculate this in order to prevent the tile looking "jumpy" when it's redrawn

        var groundOffsetX = player.x % 128; // Number of tank tiles on x axis
        var groundOffsetY = player.y % 128; // Number of tank tiles on y axis

        for (var i = -numberOfTiles; i <= numberOfTiles; i++) {
            for (var j = -numberOfTiles; j <= numberOfTiles; j++) {
                groundTiles.addFrame('imgs/imgGround.png', i * tileSizeX, j * tileSizeY);
            }
        }


        // We'll use these later to animate the building
        var animateX = 1;
        var animateY = 0;

        /**
         * We'll draw the building off the players viewport to start to give it the impression we're driving past
         * @type {number}
         */
        var buildingTexture = new PIXI.Texture(
                PIXI.utils.TextureCache['imgs/imgBuildings.png'],
                new PIXI.Rectangle(0, 0, 144, 144, 144)
        );
        groundTiles.addFrame(buildingTexture, (2 * 128), (4 * 128) * -1, animateX, animateY);

        groundTiles.position.set(playerOffsetX + player.x - groundOffsetX, playerOffsetY + player.y - groundOffsetY);
    }

    var tick = new Date().getTime();
    var tileAnim = 0;
    var tileAnimationTick = 0;
    function gameLoop() {


        stats.begin();

        tick = new Date().getTime();
        if (player.y % (10 * tileSizeY ) === -0) {
            console.log("redrawing");
            drawTiles();
        }

        // Make it look like the tank is driving forwards by moving the tiles
        player.y -= 4;
        groundTiles.pivot.set(player.x, player.y);

        app.renderer.plugins.tilemap.tileAnim[0] = tileAnim * 144;
        if (tick > tileAnimationTick) {
            tileAnimationTick = tick + 300;

            tileAnim = tileAnim + 1;
            if (tileAnim >= 3) {

                tileAnim = 0;
            }
        }

        stats.end();
        requestAnimationFrame(gameLoop);
    }
    </script>
    <script>
      // console.log(PIXI)
      // console.log(PIXI.tilemap)
      // // We create a class where to store the sliced tiles from the tileset image resource
      // class TileSet {
      //   constructor({
      //     tilewidth,
      //     tileheight,
      //     texture,
      //     offset,
      //     count,
      //     scaleMode
      //   }) {
      //     this.tilewidth = tilewidth;
      //     this.tileheight = tileheight;
      //     this.offset = offset || 0;
      //     this.texture = texture;
      //     this.textureCache = [];
      //     this.scaleMode = scaleMode || PIXI.SCALE_MODES.NEAREST;
      //     this.prepareTextures(count);
      //   }
      //   get width() {
      //     return this.texture.width;
      //   }
      //   get height() {
      //     return this.texture.height;
      //   }
      //   prepareTextures(count) {
      //     var size =
      //       count ||
      //       (this.width / this.tilewidth) * (this.height / this.tileheight);

      //     this.textureCache = new Array(size)
      //       .fill(0)
      //       .map((_, frame) => this.prepareTexture(frame));
      //   }
      //   prepareTexture(frame) {
      //     var cols = Math.floor(this.width / this.tilewidth);
      //     var x = ((frame - this.offset) % cols) * this.tilewidth;
      //     var y = Math.floor((frame - this.offset) / cols) * this.tileheight;
      //     var rect = new PIXI.Rectangle(x, y, this.tilewidth, this.tileheight);
      //     var texture = new PIXI.Texture(this.texture, rect);

      //     texture.baseTexture.scaleMode = this.scaleMode;
      //     texture.cacheAsBitmap = true;

      //     return texture;
      //   }
      //   getFrame(frame) {
      //     if (!this.textureCache[frame]) {
      //       this.prepareTexture(frame);
      //     }

      //     return this.textureCache[frame];
      //   }
      // }
      // var TIME = 0;
      // var resolutionX = 1024;
      // var resolutionY = 720;

      // var stats = new Stats();
      // stats.showPanel(0);
      // document.body.appendChild(stats.dom);

      // var app = new PIXI.Application(resolutionX, resolutionY);
      // document.body.appendChild(app.view);

      // // We need to load the tileset image resource and the exported json file from tiled that stores the tilemap and tileset data
      // PIXI.loader.add(["imgs/Viking3.png", "imgs/island.json"]).load(setup);

      // function setup(loader, resources) {
      //   PIXI.tilemap.Constant.boundSize = 2048;
      //   PIXI.tilemap.Constant.bufferSize = 4096;
      //   console.log(loader, resources);
      //   var island = resources["imgs/island.json"].data;

      //   // Here we take the first tileset in the tiled file. If you have multiple, you might need to do something different
      //   var tileset = island.tilesets[0];
      //   var { tileheight, tilewidth, tilecount } = tileset;

      //   var TILESET = new TileSet({
      //     tilewidth,
      //     tileheight,
      //     texture: PIXI.utils.TextureCache["imgs/Viking3.png"],
      //     offset: 1,
      //     count: tilecount,
      //     tileset,
      //     scaleMode: PIXI.SCALE_MODES.NEAREST
      //   });

      //   var TILEMAP = new PIXI.tilemap.CompositeRectTileLayer(0);
      //   app.stage.addChild(TILEMAP);

      //   island.layers.forEach(layer => {
      //     if (!layer.visible) return;
      //     if (layer.type === "objectgroup") {
      //       layer.objects.forEach(object => {
      //         var { gid, id, width, height, x, y, visible } = object;
      //         if (visible === false) return;
      //         if (TILESET.getFrame(gid)) {
      //           TILEMAP.addFrame(TILESET.getFrame(gid), x, y - tileheight);
      //         }
      //       });
      //     } else if (layer.type === "tilelayer") {
      //       var ind = 0;
      //       for (var i = 0; i < layer.height; i++) {
      //         for (var j = 0; j < layer.width; j++) {
      //           var xPos = tilewidth * j;
      //           var yPos = tileheight * i;

      //           var tileUid = layer.data[ind];

      //           if (tileUid !== 0) {
      //             var tileData = tileset.tiles.find(
      //               tile => tile.id === tileUid - 1
      //             );

      //             // Animated tiles have a limitation with only being able to use frames arranged one to each other on the image resource
      //             if (tileData && tileData.animation) {
      //               TILEMAP.addFrame(
      //                 TILESET.getFrame(tileUid),
      //                 xPos,
      //                 yPos
      //               ).tileAnimX(tilewidth, tileData.animation.length);
      //             } else {
      //               // Non animated props dont require tileAnimX or Y
      //               TILEMAP.addFrame(TILESET.getFrame(tileUid), xPos, yPos);
      //             }
      //           }

      //           ind += 1;
      //         }
      //       }
      //       app.start();
      //     }
      //   });
      //   gameLoop();
      // }

      // // For tracking stats
      // function gameLoop() {
      //   stats.begin();
      //   stats.end();
      //   requestAnimationFrame(gameLoop);
      // }

      // // We increment time by one whenever we want to progress all tile animations
      // setInterval(() => {
      //   TIME += 1;
      //   // tileAnim[0] will move time on the X axis, while tileAnim[1] on the Y
      //   app.renderer.plugins.tilemap.tileAnim[0] = TIME;
      //   app.renderer.render(app.stage);
      // }, 100);
    </script>
  </body>
</html>
